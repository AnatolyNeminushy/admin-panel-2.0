/**
 * Утилиты для работы с датами в аналитике.
 *
 * Зачем:
 * - Единообразно форматируем дату в ISO `YYYY-MM-DD` (UTC), пригодно для API/SQL/логов.
 * - Безопасно сдвигаем дату на N календарных дней без мутации исходного объекта.
 *
 * Важно:
 * - Форматирование идёт через `toISOString()` → берём первые 10 символов. Это именно UTC-дата.
 *   Если вам нужна локальная дата пользователя — используйте другой форматтер (например, Intl.DateTimeFormat).
 * - `addDays` считает КАЛЕНДАРНЫЕ дни (`setDate`), корректно проходя через границы месяцев/лет и переходы DST.
 * - Строковые даты парсятся штатным конструктором `Date`. Чтобы избежать сюрпризов, используйте ISO-строки (`2025-10-19`).
 * - Перед работой все входные значения валидируются: при некорректной дате бросаем понятную ошибку, чтобы баг
 *   проявился раньше (fail-fast подход).
 *
 * Подсказка для будущего читателя:
 * - Если нужна «чистая» арифметика по миллисекундам (без календарной логики), используйте `getTime()` и константу
 *   миллисекунд в сутках. Здесь оставили календарную семантику как более ожидаемую в UI/отчётах.
 */

/** Явно описываем допустимые входы для наших утилит. */
export type DateInput = Date | string | number;

/**
 * Внутренний хелпер: нормализует вход к валидному `Date` и делает безопасную копию.
 * - Если пришёл `Date`, клонируем по таймстемпу (не через `new Date(date)` — это парсит строку!).
 * - Если число/строка — создаём `Date` как обычно.
 * Бросает `TypeError`, если дата некорректна.
 */
function normalizeDate(input: DateInput): Date {
  const d = input instanceof Date ? new Date(input.getTime()) : new Date(input);
  if (Number.isNaN(d.getTime())) {
    // Используем TypeError как более точный тип ошибки для неверного значения.
    throw new TypeError('Invalid date input');
  }
  return d;
}

/**
 * Возвращает дату в ISO-формате `YYYY-MM-DD` (UTC, без времени).
 *
 * Примеры:
 *   fmtISO(new Date('2025-10-19T23:59:59Z')) // '2025-10-19'
 *   fmtISO('2025-10-19T12:00:00+03:00')      // '2025-10-19'
 */
export function fmtISO(input: DateInput): string {
  const date = normalizeDate(input);
  // ISO-строка в UTC имеет вид 'YYYY-MM-DDTHH:mm:ss.sssZ' → первые 10 символов — нужный нам формат.
  return date.toISOString().slice(0, 10);
}

/**
 * Возвращает НОВЫЙ объект `Date`, сдвинутый на `delta` календарных дней относительно исходной даты.
 * Исходный `Date` НЕ мутируется.
 *
 * Поведение:
 * - Невалидный `input` → бросаем TypeError (fail-fast).
 * - `delta` приводим к целому через `Math.trunc`. Нефинитные значения трактуем как 0.
 *
 * Примеры:
 *   addDays('2025-10-19', 1)  // -> 2025-10-20T00:00:00.000Z (в терминах UTC)
 *   addDays(new Date(), -7)   // дата неделей раньше
 */
export function addDays(input: DateInput, delta: number): Date {
  const base = normalizeDate(input);
  const days = Number.isFinite(delta) ? Math.trunc(delta) : 0;

  // Делаем копию и сдвигаем календарно: setDate корректно перекатывает месяц/год и учитывает DST.
  const result = new Date(base.getTime());
  result.setDate(result.getDate() + days);
  return result;
}
