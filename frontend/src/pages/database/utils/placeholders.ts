/**
 * Модуль временных (placeholder) идентификаторов.
 *
 * Зачем это нужно:
 * - Пока запись ещё не сохранена в БД и не получила «настоящий» ID, ей удобно выдать
 *   безопасный временный идентификатор, чтобы её можно было рендерить, сортировать,
 *   искать в массивах/картах и оптимистично обновлять UI.
 *
 * Как устроено:
 * - Placeholder-ID — это **отрицательное** число, значительно меньше любых реальных ID.
 *   Такой выбор гарантирует отсутствие коллизий с обычными положительными автоинкрементами/UUID-ас-number.
 * - Значение строится на основе текущего времени, что делает ID детерминированно «убывающим»
 *   (новее — меньше), что удобно для списков с сортировкой по дате.
 *
 * Нюансы, о которых легко забыть:
 * - Мы остаёмся в диапазоне `Number.isSafeInteger` (±9_007_199_254_740_991), чтобы не терять точность.
 * - Функция генерации следит за монотонностью внутри одного процесса: если два вызова пришлись на одну миллисекунду,
 *   второй ID будет дополнительно уменьшен, чтобы остаться уникальным и строго убывающим.
 */

// Очень маленькое (отрицательное) значение для временных ID, чтобы не пересекаться с реальными.
// Число остаётся в пределах безопасных целых JS и фиксировано как литерал для предсказуемости.
export const PLACEHOLDER_MIN = -900_000_000_000_000 satisfies number;

/**
 * Проверяет, является ли значение корректным placeholder-ID.
 * Используем user-land type guard: на выходе TypeScript понимает, что это number.
 */
export function isPlaceholderId(id: unknown): id is number {
  return (
    typeof id === 'number' &&
    Number.isFinite(id) &&
    Number.isSafeInteger(id) &&
    id <= PLACEHOLDER_MIN
  );
}

// Запоминаем последний выданный ID, чтобы сохранять строго убывающую последовательность в рамках процесса.
// Неочевидный момент: `Date.now()` имеет миллисекундную гранулярность, из-за чего возможны совпадения.
// Этот буфер гарантирует уникальность без внешних зависимостей.
let lastIssued = PLACEHOLDER_MIN - Date.now();

/**
 * Генерирует уникальный временный (отрицательный) ID.
 * Чем «новее» сущность — тем меньше (более отрицательное) значение она получит.
 */
export function makePlaceholderId(): number {
  // Кандидат строим на основе текущего времени — это даёт естественную убывающую шкалу.
  const candidate = PLACEHOLDER_MIN - Date.now();

  // Если два вызова пришлись на один тик времени, обеспечим строгое убывание вручную.
  // Обязательно остаёмся в диапазоне безопасных целых.
  const next =
    candidate < lastIssued
      ? candidate
      : (lastIssued - 1);

  // Страхуемся от выхода за пределы безопасных целых (практически недостижимый кейс, но check дешёвый).
  if (!Number.isSafeInteger(next)) {
    throw new Error('Generated placeholder ID is not a safe integer.');
  }

  lastIssued = next;
  return next;
}
