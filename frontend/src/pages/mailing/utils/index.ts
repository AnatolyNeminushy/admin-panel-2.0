/**
 * Утилиты для модуля рассылок.
 *
 * Что здесь и зачем:
 * - safeJson   — безопасный JSON.parse, который не «роняет» поток выполнения и возвращает null при ошибке.
 * - parseManualIds — бережно разбирает список ID, введённых вручную (пробелы, запятые, переносы строк),
 *   нормализует строку, убирает дубликаты и пустые элементы.
 * - canSend    — единая проверка «готовности» к отправке: есть ли текст/платформа или выбранные ID
 *   (в зависимости от режима отправки).
 *
 * Почему так:
 * - Входы типизированы через `unknown` и узкие типы-алиасы — это повышает надёжность и облегчает последующую эволюцию API.
 * - Используем `Readonly`-обёртки и `readonly`-массивы/сеты в сигнатурах — из коробки защищаемся от непреднамеренных мутаций.
 * - Разделители в `parseManualIds` покрывают unicode-пробелы и типовые пунктуационные символы; дополнительно выполняем NFC-нормализацию,
 *   чтобы одинаковые визуально символы не дублировались из-за разной композиции Unicode.
 * - В `canSend` вынесена проверка выбранных ID в отдельный хелпер `hasAnySelectedIds` — так проще читать и переиспользовать.
 * - Никаких устаревших конструкций: только явные типы, строгая работа с `unknown`, аккуратные null-safe операции.
 */

/* ---------------------------------------------
 * Типы
 * ------------------------------------------- */

export type Id = string | number;

/**
 * Режим отправки:
 * - "selected" — отправляем только выбранным пользователям (обязательны выбранные ID).
 * - Любой другой режим (например, "all" / "segment") — отправляем по тексту и выбранным платформам.
 *
 * Примечание: не фиксируем закрытый union на будущее — оставляем возможность расширения.
 */
export type SendMode = "selected" | (string & {});

/** Параметры готовности к отправке. */
export interface CanSendParams {
  /** Текст сообщения (для «широкой» отправки). */
  readonly text?: string;
  /**
   * Карта платформ: ключ — internal-идентификатор платформы, значение — включена ли отправка.
   * Допускаем `undefined` для совместимости с неполными формами.
   */
  readonly platforms?: Readonly<Record<string, boolean | undefined>>;
  /** Режим отправки (см. SendMode). */
  readonly sendMode?: SendMode;
  /**
   * Набор выбранных ID для режима "selected".
   * Принимаем как Set, так и массив — чтобы не привязывать вызывающий код к конкретной коллекции.
   */
  readonly selectedIds?: ReadonlySet<Id> | readonly Id[];
}

/* ---------------------------------------------
 * safeJson
 * ------------------------------------------- */

/**
 * Безопасный JSON.parse — при ошибке вернёт null.
 *
 * Подсказка: если ожидаете строгий тип результата, параметризуйте дженерик `<T>`.
 * Пример:
 *   const data = safeJson<MyDto>(payload);
 */
export function safeJson<T = unknown>(text: string): T | null {
  try {
    return JSON.parse(text) as T;
  } catch {
    return null;
  }
}

/* ---------------------------------------------
 * parseManualIds
 * ------------------------------------------- */

/**
 * Разбор вручную введённых ID пользователей.
 *
 * Что делает:
 * - Превращает любой ввод в строку, подчищает BOM, нормализует в Unicode NFC.
 * - Делит по пробельным/пунктуационным разделителям: пробелы, табы, переносы, запятые, точки с запятой и т.п.
 * - Убирает пустые элементы и дубликаты, сохраняет порядок первых вхождений.
 *
 * Возвращает массив строковых ID (если нужны числа — преобразуйте в вызывающем коде осознанно).
 */
export function parseManualIds(input: unknown): string[] {
  const source = String(input ?? "")
    // На случай копипаста с BOM в начале:
    .replace(/^\uFEFF/u, "")
    // Нормализация в составную форму — спасает от «визуально одинаковых, но бинарно разных» символов:
    .normalize("NFC");

  // Разделители: любые пробелы (включая неразрывный / узкий), запятые, точки с запятой, вертикальные черты.
  const raw = source.split(/[\s,;|]+/u);

  const seen = new Set<string>();
  const result: string[] = [];

  for (const chunk of raw) {
    const token = chunk.trim();
    if (!token) continue;
    if (seen.has(token)) continue;
    seen.add(token);
    result.push(token);
  }

  return result;
}

/* ---------------------------------------------
 * canSend
 * ------------------------------------------- */

/**
 * Проверка, можно ли отправлять рассылку.
 *
 * Логика:
 * - Режим "selected": обязательно наличие хотя бы одного ID в selectedIds.
 * - Прочие режимы: нужен непустой текст и хотя бы одна включённая платформа.
 *
 * UX-подсказка: проверку можно дергать на onChange формы и использовать как признак активности кнопки «Отправить».
 */
export function canSend({
  text = "",
  platforms = {},
  sendMode,
  selectedIds,
}: CanSendParams): boolean {
  if (sendMode === "selected") {
    return hasAnySelectedIds(selectedIds);
  }

  const hasText = text.trim().length > 0;
  const anyPlatformEnabled = Object.values(platforms).some(Boolean);

  return hasText && anyPlatformEnabled;
}

/* ---------------------------------------------
 * Вспомогательные функции (internal)
 * ------------------------------------------- */

/**
 * Есть ли выбранные ID (поддержка Set и массива).
 * Выделено отдельно для читабельности и переиспользования.
 */
function hasAnySelectedIds(selected: CanSendParams["selectedIds"]): boolean {
  if (selected instanceof Set) {
    return selected.size > 0;
  }
  if (Array.isArray(selected)) {
    return selected.length > 0;
  }
  return false;
}
