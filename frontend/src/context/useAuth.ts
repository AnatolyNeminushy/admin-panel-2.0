/**
 * Хук `useAuth` — удобная точка доступа к данным аутентификации из React-контекста.
 *
 * Зачем:
 * - Централизует получение `AuthContext` без прямой работы с `useContext` в каждом компоненте.
 * - Гарантирует корректный runtime-инвариант: хук нельзя вызывать вне провайдера — ошибка будет явной и полезной.
 *
 * Как использовать (мини-подсказка):
 * ```tsx
 * <AuthProvider>
 *   <YourComponent />  // внутри — смело вызывайте useAuth()
 * </AuthProvider>
 * ```
 * Если забыть обернуть в `AuthProvider`, хук бросит исключение с понятным текстом — это ускорит отладку.
 *
 * Детали реализации:
 * - Типы импортируются через `import type` (современная практика 2025) — это помогает tree-shaking и снижает оверхед компиляции.
 * - Явно указан возвращаемый тип `AuthContextValue` — повышает читаемость и предотвращает неявные изменения API.
 */

import { useContext } from "react";
import { AuthContext, type AuthContextValue } from "./AuthContext.shared";

/**
 * Безопасно читает значения из `AuthContext`.
 *
 * @returns {AuthContextValue} Актуальное состояние аутентификации (пользователь, токены, методы входа/выхода и т.д.).
 * @throws {Error} Если хук вызван вне `AuthProvider` — это указывает на архитектурную ошибку внедрения контекста.
 */
export function useAuth(): AuthContextValue {
  // Берём значение из контекста; по договорённости внутри AuthContext — либо объект со значениями, либо null.
  const context = useContext(AuthContext);

  // Неочевидный момент: проверка на null обязательна даже в TypeScript,
  // потому что типы стираются во время выполнения. Этот инвариант защищает от "тихих" багов.
  if (!context) {
    // Сообщение делает причину сбоя ясной и сразу подсказывает решение.
    throw new Error(
      "useAuth должен вызываться внутри AuthProvider. Оберните компонент в <AuthProvider>…</AuthProvider>."
    );
  }

  return context;
}
